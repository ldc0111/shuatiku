#### 题目大意

#### 最大路径和 I

从下面展示的三角形的顶端出发，不断移动到在下一行与其相邻的元素，能够得到的最大路径和是23。

**3**
**7** 4
2 **4** 6
8 5 **9** 3

如上图，最大路径和为 3 + 7 + 4 + 9 = 23。

求从下面展示的三角形顶端出发到达底部，所能够得到的最大路径和：

75
95 64
17 47 82
18 35 87 10

20 04 82 47 65

19 01 23 75 03 34

88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

**注意：** 在这个问题中，由于只有16384条路径，通过尝试所有的路径来解决问题是可行的。但是，对于[第67题](http://pe-cn.github.io/67)，虽然是一道相同类型的题目，但是三角形将拥有一百行，此时暴力破解将不能解决，而需要一个更加聪明的办法！;o)



#### 动态规划

定义状态

确定动态方程

程序实现



两种递推思路

１，F(i,j)是０到这个点的最大值

２，F(i,j)是从下面到这个点的最大值



无后效性

只会用到前面的值，不会改变前面的值



#### 程序实现

````c++
#include <stdio.h>

int f[22][22] = {0};
int num[22][22] = {0};


int main(){
  FILE *fp = fopen("in","r");
  for(int i = 0; i < 20; i++){
    for(int j = 0; j <= i; j++){
      fscanf(fp,"%d", &num[i][j]);
    }
  }
  for(int i = 0; i < 20; i++){
    f[19][i] = num[19][i];
  }
  for(int i = 18;i >= 0; i--){
    for(int j = 0;j <= i; j++){
      f[i][j] = (f[i + 1][j] > f[i + 1][j + 1]? f[i + 1][j] : f[i + 1][j + 1]) + num[i][j];
    }
  }
  printf("%d\n",f[0][0]);
  return 0;
}
````





总结

定义状态

写状态转移方程

完成代码



#### 三种解法

动态规划正向，逆向

从下到上



从上倒下