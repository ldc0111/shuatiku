#### 题目大意

**全数字的倍数**

将192分别与1、2、3相乘：

> 192 × 1 = 192
> 192 × 2 = 384
> 192 × 3 = 576

连接这些乘积，我们得到一个1至9全数字的数192384576。我们称192384576为192和(1,2,3)的连接乘积。

同样地，将9分别与1、2、3、4、5相乘，得到1至9全数字的数918273645，即是9和(1,2,3,4,5)的连接乘积。

对于n > 1，所有某个整数和(1,2, … ,n)的连接乘积所构成的数中，最大的1至9全数字的数是多少？





#### 代码实现

````c++
/*************************************************************************
	> File Name: euler038.cpp
	> Author:
	> Mail: 
	> Created Time: 2018年07月04日 星期三 20时17分07秒
 ************************************************************************/

#include <stdio.h>
#include <math.h>

bool ispandigital(int n, int *result){
    int num = 0, a[10] = {0};//标记数组//ｎｕｍ是记录顺序的
    int ret = 0, i = 1, x;
    while(num < 9){//统计位数
        x = n * i;//类乘
        while(x){//按位标记功能
            if(x % 10　== 0) return false;//不能有０
            if(a[x % 10]) return false;//标记过，不能有重复
            a[x % 10] = (++num);//位数加加
            x /= 10;//数字除消去一位
        }
        ret *= (int) pow(10, floor(log10(n * i)) + 1);//先乘上对应位的权值
        ret += n * i;//加进去
        ++i;//乘上后面的数
    }
    (*result) = ret;//记录结果
    return true;//返回成立
}


int main(){
    bool flag;
    int num, max_num = 0;
    for(int i = 1; i < 10000; i++){//乘１　乘２直到用两个式子相乘为１０为为止
        if(!ispandigital(i, &num)) continue;//不成立不进行后面的操作
        if(num > max_num) max_num = num;//求最大值

    }
    printf("%d\n", max_num);//输出最大值
    return 0;
}

````

#### 总结

标记数组，会方便许多

在整理用了一个技巧是放弃了ｆｏｒ循环而用ｗｈｉｌｅ循环，是因为ｗｈｉｌｅ更加合适，因为不知道截止时ｉ的大小，比较的是位数也与ｉ没有直接关系，

直接统计位数，判断位数更加合理

难到我的是１００００这个的选择，，，

还有ｎ的截止条件

１．判断１００００时

２，标记数组

３，判断每一位

４，统计每一位

５，判断位数．

